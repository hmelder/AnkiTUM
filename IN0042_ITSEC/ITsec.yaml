title: ITSec
author: Hendrik H√ºbner
id: 34857688845
cards:


- type: html
  id: 0  # (generated)
  front: Def. Angriffsvektor
  back: Eine Liste von schritten in einem Angriff


- type: html
  id: 1  # (generated)
  front: 'Was ist der unterschied zwischen: Angriff, Bedrohung und Schwachstelle?'
  back: |+
    Schwachstelle = Erm√∂glicht das Umgehen von Sicherheitskontrollen 
    Bedrohung = Ein B√∂sartiges Ereignis welches die Sicherheit von Assets gef√§hrdet
    Angriff = Konkretes ausnutzen einer Schwachstelle


- type: html
  id: 2  # (generated)
  front: Was ist ein Virus?
  back: Nicht selbst√§ndiges Programm welches sich dupliziert


- type: html
  id: 3  # (generated)
  front: Was ist ein Trojaner?
  back: Ein N√ºtzliches Programm welches versteckte schadsoftware enth√§lt


- type: html
  id: 4  # (generated)
  front: Was ist Ransomware?
  back: Scahdsoftware welche einen Opfer Rechner unbenutzbar macht bis z.b. ein L√∂segeld
    bezahlt wurde


- type: html
  id: 5  # (generated)
  front: Was sind die CIA Basisziele + Erweiterten Ziele?
  back: Confidenciality, Integrity, Availability<br><br>Authenticity, Accountability,
    Privacy


- type: html
  id: 6  # (generated)
  front: Was ist Integrity? (CIA)
  back: Schutz vor unbemerkter / unauthorisierter Modifikation von Daten


- type: html
  id: 7  # (generated)
  front: Was ist Availability? (CIA)
  back: Schutz vor Beientr√§chtigung der Funktionalit√§t


- type: html
  id: 8  # (generated)
  front: Was ist Authenticity? (CIA)
  back: Nachweis der Glaubw√ºrdigkeit der Identit√§t einer Entit√§t (Person, Computer,
    Dienst...)


- type: html
  id: 9  # (generated)
  front: Was ist Confidentiality? (CIA)
  back: Geheimhaltung sensitiver Daten


- type: html
  id: 10  # (generated)
  front: Was ist accountability? (CIA)
  back: Schutz vor unzul√§ssigem abstreiten einer Handlung


- type: html
  id: 11  # (generated)
  front: Was ist Privacy? (CIA)
  back: Die f√§higkeit einer Person die Weitergabe ihrer Daten zu Kontrollieren


- type: html
  id: 12  # (generated)
  front: Was ist symmtrische verschl√ºsselung vs asymmetrische verschl√ºsselung
  back: |+
    Symmetrisch: Geteilter (gleicher) schl√ºssel zwischen beiden Kommunikationspartnern
    welcher die nachrichten verschl√ºsselt bzw entschl√ºsselt<br><br>Asymmetrisch: Public
    / Private key verfahren


- type: html_cloze
  id: 13 # (generated)
  front: |
    <p>{{c1::Asymmetrische}} Verschl√ºsselung ist viel aufw√§ndiger als&amp;lt;br&amp;gt;{{c1::symmetrische}}.
    Es werden deshalb idR nur kleine Datenvolumen&amp;lt;br&amp;gt;verschl√ºsselt.</p>


- type: html
  id: 14  # (generated)
  front: Was sollte f√ºr eine (trapdoor) Einweg Funktion f(x) gelten?
  back: f(x) effizient berechenbar<br> <sup>-1</sup>(y) nicht effizient berechenbar&nbsp;<br><br>Mit
    einer weiteren information (schl√ºssel) ist die Umkehrfunktion allerdings doch
    effizient berechenbar


- type: html
  id: 15  # (generated)
  front: Auf welcher Einwegfunktion basiert RSA?
  back: Primzahlen Faktoriesierung f(p, q) = p * q


- type: html
  id: 16  # (generated)
  front: Auf welcher Einwegfunktion basiert DH?
  back: Diskretes Logarithmus Problem<br>f(x) = g<sup>x</sup>(mod p)


- type: html
  id: 17  # (generated)
  front: Wie berechnet sich ein RSA Schl√ºsselpaar?
  back: 1. w√§hle 2 gro√üe, geheime Primzahlen p, q (&gt; 1024 bit),<br>2. Berechne
    RSA-Modul n = pq, n ist √∂ffentlich. P, q sind geheim<br>3. Berechne phi(n) = (p
    -1)(q -1), Eulersche Phi-Funktion<br>effizient zu berechnen, wenn p, q Primzahlen
    sind.<br>3. W√§hle e aus {1, 2, ‚Ä¶, phi(n)-1} so, dass gilt<br>ggT(phi(n), e) =
    1, (e, n) ist der √∂ffentliche Schl√ºssel.<br><br>4. Berechne den privaten Schl√ºssel
    d, so dass gilt:<br>ed = 1 mod phi(n).


- type: html
  id: 18  # (generated)
  front: Was ist der public key bei RSA?;
  back: (e, n)


- type: html
  id: 19  # (generated)
  front: Wie wird bei RSA Verschl√ºsselt?
  back: RSA(x) = x<sup>e</sup> &nbsp; mod n<br><br>wobei e der exponent ist


- type: html
  id: 20  # (generated)
  front: Wie wird bei RSA entschl√ºsselt?
  back: RSA<sup>-1</sup>(y) = y<sup>d</sup>&nbsp;mod n<br><br>wobei d der private
    key ist&nbsp;

- type: basic
  id: 84  # (generated)
  front: Was ist chacha20?
  back: Ein AEAD Algorithmus (stromchiffre). Wird noch verwendet, allerdings gibt
    es erweiterte versionen.

- type: markdown
  id: 85  # (generated)
  front: Nenne symmetrische und asymmetrische verfahren
  back: |+
    symmetrisch:
    - AES
    - ChaCha20
    asymmetrisch:
    - RSA
    - ECC


- type: html
  id: 21  # (generated)
  front: Welches Problem gibt es bei Textbook RSA? L√∂sung?
  back: Deterministisch, d.h. die gleiche Nachricht erzeugt den Gleichen Kryptotext.
    L√∂sung durch Zuf√§lliges Padding


- type: html
  id: 22  # (generated)
  front: Was ist Kerckhoffs Prinzip?
  back: St√§rke des Verfahren sollte nur von der G√ºte des geheimen<br>Schl√ºssels abh√§ngen!<br><br>Sicherheit
    darf nicht von Geheimhaltung der Verfahren<br>abh√§ngen, Keine Security by Obscurity!


- type: html
  id: 23  # (generated)
  front: Welchen Vorteil hat elliptic curve cryptography gegen√ºber RSA?
  back: Deutlich k√ºrzere Schl√ºssel


- type: html
  id: 24  # (generated)
  front: Was ist eine Blockchiffre?
  back: Symmetrisches verfahren. Klartext wird blockweise verschl√ºsselt


- type: html
  id: 25  # (generated)
  front: '"""Welches Problem haben """"reine"""" blockchriffren?"""'
  back: Determinismus, gleiche Bl√∂cke haben gleichen Kryptotext.


- type: html
  id: 26  # (generated)
  front: Warum ben√∂tigen Blockchiffren Padding?
  back: Letzter Block muss evtl aufgef√ºllt werden<br><br>letzten block mit bytes mit
    dem gleichen wert wie die Anzahl der freien bytes auff√ºllen.


- type: html
  id: 27  # (generated)
  front: 'Blockchiffren: Diffusion vs Konfusion?'
  back: 'Diffusion: Jedes Klartextbit beeinflusst jedes Ciphertextbit<br>Konfusion:
    Zusammenhang zwischen Key und Ciphertext verschleiern z.b. durhcn nicht lineare
    substitution'

- type: basic
  id: 86  # (generated)
  front: Was ist der Avalanche effekt?
  back: Kleine √Ñnderung in klartext verursacht gro√üe √§nderung im cyphertext

- type: html
  id: 28  # (generated)
  front: Was ist eine Stromchiffre?
  back: Ein symmetrisches Verschl√ºsselungsverfahren wo der Klartext mit einem Strom
    aus schl√ºsseln kombiniert wird (durch XOR)<br>


- type: html
  id: 29  # (generated)
  front: Welche Schwachstelle gibt es bei Stromchiffren mit der gleichen Schl√ºsselfolge?
  back: wenn der Angreifer beide Kryptotexte und einen der Klartexte kennt, Kann der
    andere Klartext durch XOR operationen entschl√ºsselt werden


- type: html
  id: 30  # (generated)
  front: Was macht der ECB modus von AES? ISt er sicher?
  back: Verschl√ºsselt jeden Block separat. Sehr unsicher


- type: html
  id: 31  # (generated)
  front: Was macht der CBC modus von AES? Ist er sicher?
  back: |+
    Der Klartext wird vor der AES Operation mit dem Kryptotext des vorherigen
    Blocks XOR genommen. F√ºr den ersten Block wird der Initialisierungsvektor IV verwendet.

    Relativ sicher, wenn IV regelm√§√üig gewechselt wird. Padding oracle angriff  evtl m√∂glich
    .


- type: html
  id: 32  # (generated)
  front: Was macht der CTR modus von AES? Ist er sicher?
  back: Der Klartext jedes Blocks wird mit einer Nonce und einem Counter wert XOR
    genommen. Der Counter wert ist der n-te Block index<br><br>Sicher.


- type: html
  id: 33  # (generated)
  front: Was macht der GCM modus von AES? Ist er sicher?
  back: √Ñhnlich zum CTR Modus, bindet allerdings noch weitere informationen zur Authenzit√§t
    in den Cryptotext ein. Sicher.


- type: html
  id: 34  # (generated)
  front: Welche Schutzziele verfolgen Hashfunktionen?
  back: Integriet√§t und Vertraulichkeit


- type: html
  id: 35  # (generated)
  front: Was ist das Merkle-Damgard Verfahren?
  back: Wird in vielen veralteten Hashfunktionen verwendet. Zerlegung des Klartexts
    in Bl√∂cke, und Blockweises Hashen mit dem vorherigen Block.


- type: html
  id: 36  # (generated)
  front: Welche Anforderungen an Hashfunktionen gibt es?
  back: |+
    Einwegeigenschaft: h = H(m) effizient berechenbar, umkehrfunktion nicht effizient
    berechenbar<br><br>Schwache Kollisionsresitenz: es ist nicht M√∂glich zu einem
    m ein m' zu finden sodass H(m) = H(m')<br><br>Starke Kollisionsresitenz: es ist
    nicht m√∂glich, effizient zwei verschiedene Texte mit gleichem Hash zu finden<br><br>


- type: html
  id: 37  # (generated)
  front: Was ist das Geburtstagsparadoxon im Bezug auf Hashing?
  back: Hashkollisionen passieren deutlich H√§ufiger als oft intuitiv angenommen wird.


- type: html
  id: 38  # (generated)
  front: Was sind die unterschiede zwischen SHA1,2,3?
  back: 'SHA1: basiert auf MD Veraltet und unsicher (160bit)<br>SHA2: basiert auf
    MD Teilweise unsicher (256bit - 512bit)<br>SHA3: basiert auf Sponge Prinzip, heutiger
    standard'


- type: html
  id: 39  # (generated)
  front: Was ist der Sinn an passworthashing?
  back: Falls Passwortlisten geleaked werden, k√∂nnen diese nicht entschl√ºsselt werden


- type: html
  id: 40  # (generated)
  front: Welchen Vorteil hat BCrypt gegen√ºber anderen Hashfunktionen?
  back: Langsam zu berechnen, es ist also schwerer passwort BCrypt Hashes zu brute
    forcen


- type: html
  id: 41  # (generated)
  front: Was ist salting im Bezug auf Passwort hashing?
  back: Ein Zuf√§lliger Wert wird im Passwort verhasht. Macht es deutlich schwerer
    Passwort Tabellen zu verwenden und gleiche Passw√∂rter k√∂nnen nicht anhand ihrer
    hashes erkannt werden


- type: html
  id: 42  # (generated)
  front: Def. MAC?
  back: Message Authentication Code<br><br>Eine Digitale Signatur&nbsp;


- type: html
  id: 43  # (generated)
  front: Welche Schutzziele haben MACs?
  back: Integrit√§t und Authentizit√§t


- type: html
  id: 44  # (generated)
  front: Was ist ein length extension Angriff? Welche SHA versionen sind anf√§llig?
  back: 'Merkle-Damg√•rd: Gibt internen Zustand als Hashwert h aus.<br><br>Ein Angreifer
    kann deshalb einfach weiterhashen: SHA-1(h||fake)<br><br>SHA1, SHA2'


- type: html
  id: 45  # (generated)
  front: welches Verfahren h√§rtet alte SHA Versionen gegen Length extension Attacks?
  back: HMAC-Verfahren


- type: html
  id: 46  # (generated)
  front: Def. AE
  back: |+
    Authenticated Encryption

    Eine Verschl√ºsselte Nachricht mit einem Authentication Tag welches die authenzit√§t der Nachricht garantiert



- type: markdown
  id: 47  # (generated)
  front: Def. AEAD
  back: |+
    Authenticated Encryption aber zus√§tzlich ein Teil der Nachricht ist als Klartext Lesbar
    Beispiel: Netzwerk pakete. Der header ist lesbar


- type: markdown
  id: 60  # (generated)
  front: Vorteil AEAD chiffre vs MAC
  back: |+
    - AEAD chiffren verwenden nur einen Schl√ºssel
    - AEAD ist weniger fehleranf√§llig da der Nutzer MAX unf verschl√ºsselung nichts selbst verkn√ºpft


- type: markdown
  id: 92  # (generated)
  front: Unterschied signatur MAC
  back: |+
    - Signatur: mit dem private key erstellt, public key kann validieren
    - MAC: symmetrischer key n√∂tig


- type: html
  id: 48  # (generated)
  front: Wie berechnet sich der Informationsgehalt eines Zeichens welches mit Wahrscheinlichkeit
    p vorkommt?
  back: -log<sub>2</sub>(p)


- type: html
  id: 49  # (generated)
  front: Wie berechnet sich die&nbsp;Entropie einer Zeichenquelle?
  back: Erwartungswert der Informationsgehalte.&nbsp;


- type: html
  id: 50  # (generated)
  front: Wann ist der Informationsgehalt einer Zeichenquelle maximal?
  back: Wenn alle Zeichen gleich wahscheinlich sind


- type: html
  id: 51  # (generated)
  front: Unterschied TRNG, PRNG, CSPRNG?
  back: TRNG = Echte Zufallszahlen<br>PRNG = Pseudozufallszahlen<br>CSPRNG = Pseudozufallszaheln
    welche nicht vorhersagbar sind


- type: html
  id: 52  # (generated)
  front: Welche zwei Eigenschaften sollte ein CSPRNG haben?
  back: Unvorhersagbarkeit (-&gt; D√ºrfen keinen Hinweis auf internen Zustand oder
    Nachfolger/Vorg√§nger haben)<br>Gleichverteiltheit<br>


- type: basic
  id: 87  # (generated)
  front: Bsp Hardware implementierung CSRNG
  back: Nichtlinear r√ºckgekoppeltes Schieberegister

- type: html_cloze
  id: 53  # (generated)
  front: Um Schl√ºssel zwischen Mehr als zwei Kommunikationspartnern auszutauschen,
    kann ein&nbsp;{{c1::Schl√ºsselverteilungs-Server}}, auch&nbsp;{{c1::Key Distribution
    Center genannt}} verwendet werden. Man bezeichnet diesen als&nbsp;{{c1::Trusted
    Third Party (TTP)}}
  back: ''


- type: html
  id: 54  # (generated)
  front: Was ist die PFS Eigenschaft eines Schl√ºsselmanagement systems?
  back: Perfect Forward Secrecy<br><br>Wird ein schl√ºssel unsicher, d√ºrfen vorherige
    schl√ºssel nicht auch unsicher gemacht werden. D.h. Ein schl√ºssel darf nicht von
    seinen vorg√§ngern abh√§ngen


- type: html
  id: 55  # (generated)
  front: Was ist das Ziel des DH Verfahren?
  back: Sicherer Schl√ºsselaustausch eines symmetrischen Schl√ºssels.<br>


- type: html
  id: 56  # (generated)
  front: Wie funktioniert das DH Protokoll?
  back: |
    Es wird eine gro√üe Primzahl p und ein Generator Element festgelegt.<br><br>W√§hle
    private key a aus {2, ... , p - 2}<br>Berechne public key als A = g<sup>a</sup>mod
    p<br>Berechne shared key aus k = B<sup>a</sup>&nbsp;mod p = g<sup>ab</sup>&nbsp; mod p


- type: html
  id: 57  # (generated)
  front: Was ist eine Key Derivation Function (KDF)? Welchen nutzen hat sie?
  back: Berechnet einen Schl√ºssel mit l√§nge n aus einem beliebigen secret.


- type: html
  id: 58  # (generated)
  front: Wie kann ein Man in the middle angriff bei DH verhindert werden?
  back: Durch signatur der ausgetauschten public keys


- type: html
  id: 59  # (generated)
  front: Was ist ECDH?
  back: DH verfahren auf elliptischen kurven


- type: html
  id: 61  # (generated)
  front: was ist der unterschied zwischen authentisierung und authorisierung?
  back: 'Authentisierung: Nachweis der Identit√§t<br>Authorisierung: Nachweis der Berechtigungen
    einer Entit√§t'


- type: html
  id: 62  # (generated)
  front: Was ist der Unterschied zwischen Pseudonymisierung und Anonymisierung?
  back: '"""Anonymisierung hat das Ziel die Identit√§t vollkommen zu verschleiern<br><br>Pseudonymisierung
    verschleiert ebenfalls die wahre Identit√§t, allerdings kann ein Nutzer √ºber das
    Pseudonym eine """"alternative"""" Identit√§t besitzen"""'


- type: html
  id: 63  # (generated)
  front: Welche drei Klassen von Faktoren zur Authentisierung gibt es?
  back: Wissen, Besitz, Biometrie


- type: html
  id: 64  # (generated)
  front: Sollten Passw√∂rter auslaufen? (D.h. regelm√§√üig ge√§ndert werden)
  back: Nein, laut NIST Guidelines. Grund ist das Nutzer passw√∂rter sonst sehr einfach
    w√§hlen um sie sich merken zu k√∂nnen

- type: markdown
  id: 88  # (generated)
  front: Welche verfahren gelten als unsicher?
  back: |+
    Blockchiffren:
    - DES, 3DES
    - AES ECB
    Hashfunktionen
    - MD4, MD5
    - SHA1, SHA2
    


- type: markdown
  id: 65  # (generated)
  front: welche klassen von OTP Verfahren gibt es?
  back: |
    Hardware und Software Token.
    - Zeitsynchronisiert (TOTP)
    - Challenge-Response basiert

- type: html
  id: 66  # (generated)
  front: Wie funktioniert das zeitsynkronisierte, softwarebasierte OTP Verfahren TOTP?
  back: 1. Der Authenticator und Authenticatee gehen eine Verbindung ein<br>2. Die
    start Zeit wird ausgetauscht<br>3. Ein pre shared secret k wird ausgetauscht<br>4.
    Alle (z.b.) 30 sekunden generierten Authenticator und Authenticatee ein Passwort
    aus HMAC(k, current_time)


- type: html
  id: 67  # (generated)
  front: Welche sieben Anforderungen haben wir an Biometrische Autehntifikationsverfahren?
  back: '<ul><li>Universalit√§t: Jede Person besitzt das Merkmal</li><li>Eindeutigkeit:
    Merkmal ist f√ºr jede Person verschieden</li><li>Best√§ndigkeit: Merkmal ist unver√§nderlich</li><li>Quantitative
    Erfassbarkeit mittels Sensoren</li><li>Performance: Genauigkeit und Geschwindigkeit</li><li>Akzeptanz
    des Merkmals beim Benutzer</li><li>F√§lschungssicherheit</li></ul>'


- type: html
  id: 68  # (generated)
  front: Welche Klassen biometrischer Merkmale gibt es?
  back: physiologisch (statisch) z.b. fingerabdruck, gesicht<br>verhaltensmerkmale
    (dynamisch) z.b. Stimme


- type: html
  id: 69  # (generated)
  front: Unterschied FAR vs FRR?
  back: 'False Acceptance rate: Mit welcher wschlk. tritt ein False Negative auf?<br><br>False
    Rejection rate: Mit welcher wschlk. triff ein False Positive auf?'


- type: html
  id: 70  # (generated)
  front: Was ist die Equal Error Rate ERR?
  back: Wenn FAR == FRR


- type: html
  id: 71  # (generated)
  front: Bei biometrischer Authentisierung sollte die {{c1::False Acceptance Rate}}
    m√∂glichst niedrig sein. Je niedriger die {{c1::False Acceptance Rate}}, desto
    h√∂her allerdings die {{c1::False Rejection Rate}}.
  back: ''


- type: html
  id: 72  # (generated)
  front: Welche Probleme hat biometrische Authentifizierung?
  back: Zunehmende Gefahr durch deepfakes<br>Problem der √∂ffentlichen Daten und rechtliche
    Aspekte<br>H√§ufig leicht zu √ºberlisten


- type: html
  id: 73  # (generated)
  front: Was ist ein CR Verfahren?
  back: Challenge / Response<br><br>A gibt identit√§t an<br>B sendet challenge<br>A
    sendet response<br>B pr√ºft response


- type: html
  id: 74  # (generated)
  front: Welches problem haben wir bei public key exchanges? (Im bezug auf MitM attacks)
  back: 'Man kann nie wissen ob man wirklich mit der Entit√§t kommuniziert mit der
    man glaubt zu kommunizieren. L√∂sung: Zertifikate'


- type: html
  id: 75  # (generated)
  front: Was macht ein X.509 Cert?
  back: Bescheinigt bindung eines public keys an die Identit√§t einer Entit√§t


- type: html
  id: 76  # (generated)
  front: Was ist eine CA?
  back: Certificate Authority<br><br>Aussteller eines Zertifikats


- type: html
  id: 77  # (generated)
  front: Was ist eine PKI?
  back: Ein system, digitale Zertifikate auszustellen und zu pr√ºfen


- type: html
  id: 78  # (generated)
  front: Was ist eine RA?
  back: Organisation bei der Zertifikate beantragt werden k√∂nnen und welche pr√ºft,
    ob ein Zertifikat von der CA auszustellen ist


- type: html
  id: 79  # (generated)
  front: Wie kann ein Zertifikat validiert werden?
  back: Die signatur und u.a. g√ºltigkeitszeitraum werden √ºberpr√ºft. Danach wird das
    Zertifikat des owners validiert. Dies setzt sich rekursiv bis zu einer root CA
    fort der vertraut wird.


- type: html
  id: 80  # (generated)
  front: Woher wei√ü man, dass man einer root-CA vertrauen kann?
  back: Betriebssysteme / browser haben listen von vertrauensw√ºrdigen CA's gespeichert


- type: html
  id: 81  # (generated)
  front: Wie k√∂nnen Zertifikate zur√ºckgerufen werden?
  back: |+
    Durch das Certificate Status Protocol (OCSP) 
      -> Regelm√§√üiges erfragen von G√ºltigkeitsbest√§tigungen
    
    Oder Certificate Revocation Lists (CRL)
    

- type: html
  id: 82  # (generated)
  front: Was ist SSO?
  back: Single sign on<br><br>Authentisieren bei mehreren Diensten mit einem login


- type: markdown
  id: 83  # (generated)
  front: Nenne drei Schutzma√ünahmen gegeb buffer overflow angriffe
  back: |
    - Stack canaries: Magic number auf dem stack welche vom BS gepr√ºft wird
    - Data Execution Prevention: Stack wird mit NX bit als nicht ausf√ºhrbar markiert
    - Adressen werden randomisiert -> erschwertes einschleusen von bestimmten adressen

- type: markdown
  id: 89  # (generated)
  front: Welche drei Cookie attribute wurden besprochen?
  back: |+
    - Secure: Cookie darf nur √ºber HTTPS gesendet werden
    - HttpOnly: Cookie kann nicht mit Javascript ausgelesen werden
    - SameSite: Mitigiert CSRF attacken

- type: markdown
  id: 90  # (generated)
  front: Welche drei optionen hat das SameSite cookie attribut?
  back: |+
    - strict: Cookie wird nur gesendet wenn man auf der seite ist f√ºr die er ausgestellt wurde
    - lax: CSRF anf√§llige methoden werden geblockt (POST, PUT), GET erlaubt
    - none: Cookie wird immer gesendet


- type: markdown
  id: 91  # (generated)
  front: Wass muss f√ºr rsa exponenten gelten?
  back: ggT(phi(n), e) = 1, phi(n) = (p - 1)(q - 1)

- type: markdown
  id: 93  # (generated)
  front: Was ist dei Trusted COmputing Base
  back: |+
    - Mange der Hardware und software komponenten welche lkritisch f√ºr die sicherheit sind
    - Sollte m√∂glichst klein sein


- type: markdown
  id: 94  # (generated)
  front: Was ist ein PIE?
  back: |+
    - position independent executable

- type: markdown
  id: 95  # (generated)
  front: Was ist die strong tranquility regel?
  back: |+
    - Bell lapadula modell
    - Sicherheitsklassen d√ºrfen nicht zur laufzeit ge√§ndert werden


- type: markdown
  id: 96  # (generated)
  front: Problem MAC-then-encrypt
  back: Die Integrit√§t der Nachricht kann erst nach dem entschl√ºsseln festgestellt
    werden. Das kann eventuell zu problemen f√ºhren wie z.b. beim padding oracle angriff


- type: markdown
  id: 97  # (generated)
  front: Funktionsweise DH
  back: |+
    - Gro√üe primzahl p und generator g werden ausgetauscht
    - A und B w√§hlen private keys a, b kleiner p
    - g^a mod p = public key k_a
    - k_b^a mod p = private key


- type: markdown
  id: 98  # (generated)
  front: Was ist enrollment bei authentifizierung?
  back: Erfassen von biometrischen merkmalen


- type: markdown
  id: 99  # (generated)
  front: Eigenschaften OTP
  back: |+
    - Hardware basiert oder softwarebasiert
    - challenge response basiert oder zeitsynchronisiert


- type: markdown
  id: 100  # (generated)
  front: Probleme mit KDCs?
  back: |+
    - ggf. Keine Perfect forward secrecy
    - single point of failure

- type: markdown
  id: 101  # (generated)
  front: ALG vs Paketfilter vs DPI vs Firewall
  back: |2+

    Alle drei sind Firewalls!
    - Paketfilter: Analysiert paket header
    - Deep packet inspection: Analysiert auch die payload
    - Application Layer Gateway: Analysiert payload im kontext der spezifischen anwendung z.b. HTTP. SMTP


- type: markdown
  id: 102  # (generated)
  front: Welche verfahren werden alle bei TLS verwendet?
  back: |+
    - key exchange: Elliptic curve DH
    - authetifizierung des key exchange: z.b. RSA und/oder SHA f√ºr signaturen/HMACs
    - Nutzdaten: Symmetrische chiffre z.b. AES256 + GCM mode
    - Hashfunktion, z.b. SHA f√ºr die schl√ºsselableitung


- type: markdown
  id: 103  # (generated)
  front: Was ist complete mediation / zero trust ?
  back: Alle resourcen m√ºssen gesch√ºtzt werden

- type: markdown
  id: 104  # (generated)
  front: Mandatory access control vs Discretionary access control
  back: |+
    - *Discretionary*: Nutzer darf rechte weitergeben und bestimmt wer auf seine Resourcen zugreifen darf
    - *Mandatory*: Alle rechte sind vom system vergeben und m√ºssen strikt befolgt werden


- type: markdown
  id: 105  # (generated)
  front: Capabilities vs Access control lists
  back: |+
    - ACL: Einem Objekt wird eine liste von zugriffsrechten von Subjekten auf das Objekt zugeordnet Z.b. Unix file perissions
    - Capabilities: Einem Subjekt wird eine liste Rechten auf Objekte zugeordnet


- type: markdown
  id: 106  # (generated)
  front: Was sind PEP und PDP? Beispiele?
  back: |-
    - Policy decision point: F√ºhrt beim ersten Zugriff auf ein Objekt eine Kontrolle durch und stellt bescheinigung aus
    - Policy enforcement point: F√ºhrt zul√§ssigkeitskontrolle basierend auf bescheinigung aus
    - Beispiele: PDP: open() syscall stellt einen int token aus PEP: read() syscall token, wird gepr√ºft

- type: markdown
  id: 107  # (generated)
  front: Unterschied 0-RTT TLS 1-RTT TLS
  back: |+
    - 0 RTT: Server schickt mit seiner ersten nachricht verschl√ºsselte daten
    - 1 RTT: Server schickt mit seiner zweiten Nachricht verschl√ºsselte daten

- type: markdown
  id: 108  # (generated)
  front: Safety vs Security?
  back: |+
    - Safety ist Sicherheit "von innen" also z.b. sicherheit von systemabst√ºrzen, bugs, St√∂rungen etc
    - Security ist Sicherheit "von au√üen", d.h. Schwachstellen durch welche die Schutzziele verletzt werden k√∂nnen

- type: markdown
  id: 109  # (generated)
  front: Anforderungen an Biometrische Merkmale?
  back: |+
    - *Universalit√§t* (jeder muss das merkmal besitzen)
    - *Eindeutigkeit* (Es muss sch von person zu person unterscheiden)
    - *Best√§ndigkeit* (Es darf sich nicht ver√§ndern)
    - *Erfassbarkeit* (Es muss leicht messbar sein)
    - *Akzeptanz* (Die Messung muss gesellschaftlich akzeptiert sein)
    - *Performanz* (Es l√§sst sich schnell und genau erfassen)
    - *F√§lschungssicherheit*

- type: markdown
  id: 110  # (generated)
  front: HMAC bildung?
  back: H(ùëò ‚®Å ùëúùëùùëéùëë | H((ùëò ‚®Å ùëñùëùùëéùëë) | ùëö))

- type: markdown
  id: 111  # (generated)
  front: Wie funktioniert der DM length extension angriff bei einem h(k | m) hash?
    m ist bekannt
  back: |+
    1. gr√∂√üe k bestimmen (z.b. brute force)
    2. padding bestimmen, dabei l√§nge von k beachten!
    3. m2 = m + padding + "admin"
    4. h2 = h("admin") mit internem zustand von h gleich h1

- type: markdown
  id: 112  # (generated)
  front: |
    Angenommen das jedes Zeichen aus einem Passwortalphabet M gleich
    wahrscheinlich ist. Wie berechnet man die Entropie f√ºr ein Password der L√§nge
    L?
  back: |-
    log_2(|M|^L)

- type: markdown
  id: 113  # (generated)
  front: Wie funktioniert ein RSA SecureID Token?
  back: |
    ## Auf Server
    Token Seriennummer mit 128-bit Seed s (Auch auf RSA-Token)

    ## Erzeugen von OTPs
    - Alle 60 Sekunden
    - OTP = AES(TokenID | s | Zeit)
    - 6-8 Stellige Zahl

- type: markdown
  id: 114  # (generated)
  front: |
    Das OTP was der Benutzer eingibt ist wesentlich k√ºrzer, als das Resultat von
    HMAC_SHA1, oder AES. Woher kommt diese kurze Zahlenfolge also?
  back: |
    Es gibt eine "Truncate" Funktion, die geschickt den HMAC auf die Ziffernanzahl
    reduziert.

    HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))

    K repr√§sentiert das Shared Secret und C den Z√§hler.

- type: markdown
  id: 115  # (generated)
  front: Was sind Schwachpunkte von Google Authenticator?
  back: |-
    - 80-bit secret s zu kurz (RFC 4226 HOTP fordert mind. 128-bit)
    - s ist im Klartext auf Smartphone gesichert
    - Server wird nicht authorisiert

- type: markdown
  front: Was ist eine TEE?
  back: |+
    Trusted execution environment
    - Eine sichere bzw. vertrauensw√ºrde Laufzeitumgebung f√ºr programme, z.b. Container

- type: markdown
  front: Was ist Intel SGX?
  back: |+
    - Intel CPU erweiterung
    - Erlaubt es, von der CPU gesch√ºtzte Speicherbereiche zu definieren
    - Sogenannte "Enklaven" k√∂nnen on-the-fly verschl√ºsselt / entschl√ºsselt werden


- type: markdown
  front: Welche Probleme hat der default KDC aus der vorlesung?
  back: |+
    - Keine replay protection durch nonces oder timestamps
    - Teilnehme authentisieren sich nicht gegenseitig
    - Keine ticket lifetime / keine revocation
    


- type: markdown
  front: M√∂gliche angriffe auf passwort hash datenbanken?
  back: |+
    - Rainbow tables -> verhinderbar durch salting
    - brute force -> verhinderbar durch langsame hashfunktion, gro√üe hashes
    

- type: markdown
  front: Probleme textbook rsa
  back: |+
    - c < N: keine modulo berechnung, man kann die wurzel ziehen
    - Gleicher Klartext erzeugt gleichen kryptotext
    

- type: markdown
  front: Probleme 0 RTT TLS handshake
  back: |+
    - Keine PFS
    - Ein replay angriff bei den ersten nutzerdaten m√∂glich
        -> z.b. Replay einer POST request
    

- type: markdown
  id: 116  # (generated)
  front: Grenze die Begriffe Safety und Security voneinander ab!
  back: |-
    - **Safety**: Schutz vor St√∂rungen von **Innen**: Funktions- und Betriebssicherheit
    - **Security**: Schutz vor St√∂rungen von **Au√üen**: Angriffe durch Hacker, gezielte Angriffe
