title: 'GDB: Kapitel 6: Relationale Entwurfstheorie'
author: HHuebner
contributors: [hmelder]
id: 402722604

cards:
- type: markdown
  id: 0  # (generated)
  front: Was sind Funktionale Abhängigkeiten?
  back: Wenn die Werte in einer Menge von Spalten von den Werten in einer anderen
    Menge von Spalten sinngemäß abhängen nennt man sie funktional Abhängig


- type: markdown
  id: 1  # (generated)
  front: Was ist volle funktionale Abhängigkeit?
  back: |+
    - b ist funktional abhängig von a: [$] a \rightarrow b [/$]
    - a kann nicht mehr "verkleinert" werden: [$] \forall A \in a : \neg (a - {A} \to b) [/$]


- type: markdown
  id: 2  # (generated)
  front: Wenn FD [$]a \rightarrow b[/$] gilt, was sollte für alle Möglichen Werte
    c aus a gelten?
  back: |
    [$] \Pi_{b}(\sigma_{a=c}(R)) [/$] hat höchstens ein Element


- type: markdown
  id: 3  # (generated)
  front: Wenn FD [$]a \rightarrow b[/$] gilt, was sollte für alle Möglichen Werte
    c aus a gelten?
  back: |
    [$] \Pi_{b}(\sigma_{a=c}(R)) [/$] hat höchstens ein Element


- type: markdown
  id: 4  # (generated)
  front: Was ist ein Superschlüssel?
  back: Eine Menge an Spalten von der zusammengenommen alle Spalten der Relation funktional
    abhängig sind. Z.b. auch die Menge aller Spalten


- type: markdown
  id: 5  # (generated)
  front: Was ist ein Kandidatenschlüssel?
  back: Ein kleinstmöglicher Superschlüssel und potentieller Primärschlüssel

- type: markdown
  id: 6  # (generated)
  front: Wie berechnet man die Attributhülle?
  back: '[[image: attrHülle.png]]'

- type: markdown
  id: 7  # (generated)
  front: Wann heißen zwei Mengen von FDs gleich?
  back: Wenn ihre Attributhüllen gleich sind

- type: markdown
  id: 8  # (generated)
  front: Wie berechnet man die kanonische Überdeckung?
  back: '[[image: kanonische_ueberdeckung.png]]'


- type: markdown
  id: 9  # (generated)
  front: Wozu dient die kanonische Überdeckung?
  back: Berechnet eine kleinstmögliche Menge an FDs die gleich der Ursprungsmenge
    ist. Vereinfacht das berechnen von Normalformen

- type: markdown
  id: 11  # (generated)
  front: Was ist eine Updateanomalie?
  back: Wenn ein Wert geändert wird, dieser Wert allerdings duplikate hat, kann es
    sein dass diese Duplikate nicht mitgeupdated werden


- type: markdown
  id: 13  # (generated)
  front: Was ist eine Löschanomalie?
  back: Wenn zwei Entities miteinander verknüpft sind und eines gelöscht wird, kann
    es sein, dass der foreign key der anderen nicht mehr gültig ist


- type: markdown
  id: 14  # (generated)
  front: Was ist eine Einfügeanomalie?
  back: Wenn man Informationen einfügen will, allerdings felder in der Relation auf
    NULL setzen muss weil diese noch nicht feststehen


- type: markdown
  id: 15  # (generated)
  front: Was ist eine (Verlustlose) Zerlegung?
  back: Eine Relation is zwei Teilrelationen zu zerlegen sodass sie gejoint genau
    die Ursprüngliche Relation bilden


- type: markdown
  id: 16  # (generated)
  front: Welches Notwendige Kriterium muss gelten damit eine Zerlegung verlustfrei
    ist?
  back: |
    [$] R_1 \setminus R_2 \rightarrow R_1, R_2 [/$]

- type: markdown
  id: 19  # (generated)
  front: Wie überführt man eine Relation in die 3NF?
  back: '[[image: synthesealgorithmus.png]]'


- type: markdown
  id: 20  # (generated)
  front: Wie überführt man eine Relation in die BCNF?
  back: '[[image: bcnfalgo.png]]'


- type: markdown
  id: 21  # (generated)
  front: Wie überführt man eine Relation in die 4NF?
  back: '[[image: 4nf.png]]'


- type: markdown
  id: 22  # (generated)
  front: Wann ist eine Relation in Boyce-Codd Normalform?
  back: |+
    Ein Relationenschema R mit FDs F ist in Boyce-Codd Normalform, falls für jede funktionale Abhängigkeit α Ñ β mindestens eine der folgenden zwei Bedingungen gilt:
      - [$] a \subseteq b [/$], d.h. die Abhängigkeit ist trivial oder
      - a ist Superschlüssel von R.


- type: latex_plus
  id: 23  # (generated)
  front: Was ist eine Mehrwertige FD (MVD)?
  back: |
    Seien a, b und c eine Partition von R, es gilt [$] a \twoheadrightarrow b [/$] gdw: 
    für alle Tupel [$] t_1, t_2 [/$] mit [$] t_1.a = t_2.a [/$] gibt es [$] t_4, t_4 [/$] sodass:
    [$] t_1.a = t_2.a = t_3.a = t_4.a [/$]
    [$] t_3.b = t_1.b [/$]
    [$] t_4.b = t_2.b [/$]
    [$] t_3.c = t_2.c [/$]
    [$] t_4.c = t_1.c [/$]

- type: markdown
  id: 10  # (generated)
  front: Wann ist eine Relation in der 1. Normalform?
  back: |
    Wenn alle Attribute atomare Wertebereiche haben.

- type: markdown
  id: 12  # (generated)
  front: Wann ist eine Relation in der 2. Normalform?
  back: |
    **Jedes** Nichtschlüssel-Attribut [$]A \in R[/$] ist voll funktional **von jedem Kandidatenschlüssel** der Relation abhängig.

- type: markdown
  id: 18  # (generated)
  front: Wann ist eine Relation in der 3. Normalform?
  back: |
    Jede für [$]R[/$] geltende funktionale Abhängigkeit der Form [$]a \rightarrow b[/$] mit [$]a \subseteq R[/$] und [$]b \in R[/$] muss eine der Bedingungen erfüllen:

    - [$]b[/$] ist ein Primattribut, d.h. die FD ist trivial
    - [$]a[/$] ist Superschlüssel von [$]R[/$]

- type: markdown
  id: 24  # (generated)
  front: Wann ist eine Relation in der BCNF?
  back: |
    Falls für [$]a \rightarrow b[/$] mindestens eine der folgenden zwei Bedingungen gilt:
    - [$]b \subseteq a[/$], d.h. die Abhängigkeit ist trivial
    - [$]a[/$] ist Superschlüssel von [$]R[/$]

- type: markdown
  id: 25  # (generated)
  front: Wann ist eine Relation in der 4. Normalform?
  back: |
    Wenn für jede MVD [$]a \rightarrow\rightarrow b[/$] [$]\in D[/$] eine der folgenden Bedingungen gilt:
    - Die MVD ist trivial
    - [$]a[/$] ist ein Superschlüssel von [$]R[/$]

- type: markdown
  id: 26  # (generated)
  front: Wann ist eine MVD trivial?
  back: |
    [$]a \rightarrow\rightarrow b[/$] genau dann trivial, wenn gilt:

     1. [$]b \subseteq a[/$] oder
     2. [$]b = R - a[/$]

- type: markdown
  id: 27  # (generated)
  front: Wann ist eine FD *voll* funktional abhängig?
  back: |
    Es gilt [$]a \stackrel{\cdot}{\rightarrow} b[/$], falls beide folgenden Kriterien gelten:

    1. [$]a \rightarrow b[/$] d.h. [$]b[/$] ist funktional abhängig von [$]a[/$]
    2. [$]a[/$] kann nicht mehr "verkleinert" werden, d.h. 
    [$]\forall A \in a: a - \{A\} \not\to b[/$]  
